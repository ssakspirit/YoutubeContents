---
title: "멀티플레이에 필요한 팀채팅 구현하기"
date: "2025-04-25"
thumbnail: "https://i.ytimg.com/vi/KZuXZUz02q8/hqdefault.jpg"
tags: ["고급", "에듀케이션", "베드락", "스크립트API", "서버", "소스코드", "설계자", "롱폼"]
url: "https://www.youtube.com/watch?v=KZuXZUz02q8"
duration: "6:54"
difficulty: "고급"
---

# 멀티플레이에 필요한 팀채팅 구현하기

<div align="center">
<img src="https://i.ytimg.com/vi/KZuXZUz02q8/hqdefault.jpg" alt="썸네일" width="600"/>
</div>

## 목차
- [소개](#소개)
- [주요 내용](#주요-내용)
- [실습 과정](#실습-과정)
- [자주 묻는 질문](#자주-묻는-질문)
- [추가 리소스](#추가-리소스)

## 소개
이 영상은 마인크래프트 베드락 에디션에서 스크립트 API를 활용하여 팀 채팅 시스템을 구현하는 방법을 설명합니다. 멀티플레이 환경에서 같은 팀에 속한 플레이어끼리만 채팅 메시지를 주고받을 수 있는 기능을 만들고, 관리자 권한을 통해 플레이어 팀을 설정하는 방법까지 자세히 다룹니다. 동적 속성(Dynamic Property)을 활용하여 서버 재시작 후에도 팀 설정이 유지되는 구현 방법을 배울 수 있습니다.

## 주요 내용

### 1. 팀 채팅 시스템 개요
- 멀티플레이에서 동일 팀원에게만 채팅 메시지를 보내는 기능
- 팀 설정 명령어를 통해 사용자가 직접 팀 설정 가능
- 관리자 권한을 가진 플레이어는 다른 플레이어의 팀 강제 지정 가능
- 동적 속성을 이용해 설정된 팀은 서버 재시작 후에도 유지됨

### 2. 팀 관련 명령어 구현
- 플레이어 팀 설정 명령어: !setteam [팀이름]
- 관리자용 팀 설정 명령어: !adminsetteam [플레이어] [팀이름]
- 팀 목록 확인 명령어: !teamlist
- 팀 채팅 명령어: !t [메시지] 또는 !team [메시지]

### 3. 스크립트 API 활용
- 채팅 메시지 구독을 통한 명령어 인식
- 동적 속성(Dynamic Property)을 활용한 플레이어 팀 정보 저장
- 조건문을 활용한 팀 채팅 메시지 필터링
- 관리자 권한 확인을 위한 태그 시스템 활용

## 실습 과정

1. **팀 채팅 시스템 설정 (00:00-02:30)**
   - 채팅창에 !setteam 명령어로 자신의 팀 설정하기
   - 예: "!setteam A"를 입력하여 A팀으로 설정
   - 관리자 권한 설정: 태그 시스템을 통해 "admin" 태그 부여
   - 관리자 명령어 사용: "!adminsetteam [플레이어명] [팀이름]"
   - 팀 목록 확인: "!teamlist" 명령어로 모든 팀과 소속 플레이어 확인

2. **팀 채팅 메시지 전송 (02:31-04:30)**
   - "!t [메시지]" 또는 "!team [메시지]" 명령어로 팀 채팅 시작
   - 팀을 설정하지 않은 플레이어에게는 팀 설정 안내 메시지 표시
   - 팀 채팅 메시지는 같은 팀 플레이어에게만 표시됨
   - 동적 속성으로 설정된 팀은 서버 재시작 후에도 유지

3. **코드 구조 분석 (04:31-끝)**
   - 채팅 메시지 구독과 명령어 인식 구조 이해하기
   - 플레이어 팀 확인 및 저장 함수 분석
   - 팀 메시지 전송 함수의 작동 원리
   - 관리자 권한 확인 함수 및 다른 플레이어 팀 설정 기능 구현
   - 맵(Map) 자료구조를 활용한 팀 목록 관리 및 표시 방법

## 자주 묻는 질문

**Q: 관리자 권한은 어떻게 설정하나요?**
A: 관리자 권한은 "admin" 태그를 플레이어에게 부여하여 설정합니다. 태그가 있는 플레이어만 관리자 명령어(예: !adminsetteam)를 사용할 수 있습니다. 태그는 일반적인 마인크래프트 태그 시스템을 통해 부여할 수 있습니다.

**Q: 팀 설정은 서버를 재시작해도 유지되나요?**
A: 네, 팀 설정은 동적 속성(Dynamic Property)으로 저장되기 때문에 서버를 재시작해도 유지됩니다. 플레이어가 다시 접속하더라도 이전에 설정한 팀이 그대로 적용됩니다.

**Q: 이 코드를 다른 프로젝트에 적용하려면 어떻게 해야 하나요?**
A: 이 코드는 스크립트 API를 사용하므로, 베드락 에디션 서버나 애드온에 스크립트 파일로 추가할 수 있습니다. behavior_pack 폴더 내 scripts 디렉토리에 .js 파일로 저장하고, manifest.json에 스크립트 모듈을 추가하면 됩니다.

**Q: 팀 채팅 외에 전체 채팅은 어떻게 사용하나요?**
A: 일반 채팅 메시지(특별한 명령어 없이 입력)는 모든 플레이어에게 전송됩니다. 팀 채팅은 "!t" 또는 "!team" 명령어로 시작하는 메시지만 해당됩니다.

## 추가 리소스
- [마인크래프트 공식 웹사이트](https://www.minecraft.net/)
- [마인크래프트 베드락 스크립트 API 문서](https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/)
- [스티브코딩 유튜브 채널](https://www.youtube.com/channel/UCFGYIngtxH4lhxsGpLv8mzA)
- [스티브코딩 공식 웹사이트](https://stevecoding.kr/)

## 이런 분들에게 추천합니다
- 마인크래프트 베드락 에디션에서 서버를 운영하는 관리자
- 스크립트 API를 활용해 고급 기능을 구현하고 싶은 개발자
- 멀티플레이어 게임에 팀 시스템을 구축하고 싶은 맵 제작자
- 서버 관리 및 운영에 필요한 명령어 시스템을 개발하려는 코더
- 마인크래프트에서 채팅 시스템을 커스터마이징하고 싶은 플레이어

## 관련 튜토리얼
- 스크립트 API의 첫걸음, 채팅명령어 만들기 #애드온제작
- 스크립트 API로 본격적으로 애드온 제작하기 #애드온제작
- 서버에 입장, 재입장하는 플레이어에게 맞춤 메시지 보내기
- 서버에서 필수! 길드 시스템 구현

## 실습 코드
```javascript
// 팀 채팅 시스템 구현 코드
import { world, system, Player } from "@minecraft/server";

// 채팅 메시지 구독 및 처리
world.events.beforeChat.subscribe((event) => {
  const player = event.sender;
  const message = event.message;
  
  // 팀 채팅 명령어 처리
  if (message.startsWith("!t ") || message.startsWith("!team ")) {
    event.cancel = true;
    const teamMessage = message.replace(/^!t\s+|^!team\s+/, "");
    const playerTeam = getPlayerTeam(player);
    
    if (playerTeam) {
      sendTeamMessage(player, playerTeam, teamMessage);
    } else {
      player.tell("§c팀이 설정되어 있지 않습니다. !setteam [팀이름]으로 팀을 설정하세요.");
    }
  }
  
  // 팀 설정 명령어 처리
  else if (message.startsWith("!setteam ")) {
    event.cancel = true;
    const team = message.replace("!setteam ", "");
    setPlayerTeam(player, team);
    player.tell("§a팀이 " + team + "로 설정되었습니다.");
  }
  
  // 팀 목록 확인 명령어
  else if (message === "!teamlist") {
    event.cancel = true;
    showTeamList(player);
  }
  
  // 관리자의 다른 플레이어 팀 설정 명령어
  else if (message.startsWith("!adminsetteam ")) {
    event.cancel = true;
    if (!isAdmin(player)) {
      player.tell("§c관리자 권한이 없습니다.");
      return;
    }
    
    const args = message.split(" ");
    if (args.length !== 3) {
      player.tell("§c사용법: !adminsetteam [플레이어] [팀이름]");
      return;
    }
    
    const targetPlayer = world.getPlayers().find(p => p.name === args[1]);
    if (targetPlayer) {
      setPlayerTeam(targetPlayer, args[2]);
      player.tell("§a" + targetPlayer.name + "의 팀을 " + args[2] + "로 설정했습니다.");
    } else {
      player.tell("§c플레이어를 찾을 수 없습니다: " + args[1]);
    }
  }
});

// 플레이어의 팀 가져오기
function getPlayerTeam(player) {
  return player.getDynamicProperty("team");
}

// 플레이어 팀 설정하기
function setPlayerTeam(player, team) {
  player.setDynamicProperty("team", team);
}

// 팀 메시지 전송하기
function sendTeamMessage(sender, team, message) {
  for (const player of world.getPlayers()) {
    if (getPlayerTeam(player) === team) {
      player.tell("§9[팀채팅] §f" + sender.name + ": " + message);
    }
  }
}

// 팀 목록 보여주기
function showTeamList(player) {
  const teams = new Map();
  
  // 모든 플레이어를 팀별로 분류
  for (const p of world.getPlayers()) {
    const team = getPlayerTeam(p);
    if (team) {
      if (!teams.has(team)) {
        teams.set(team, []);
      }
      teams.get(team).push(p.name);
    }
  }
  
  // 팀 정보 메시지 구성
  if (teams.size === 0) {
    player.tell("§c설정된 팀이 없습니다.");
    return;
  }
  
  let message = "§a=== 팀 목록 ===";
  for (const [teamName, members] of teams.entries()) {
    message += "\n§6" + teamName + "§f: " + members.join(", ");
  }
  
  player.tell(message);
}

// 관리자 권한 확인
function isAdmin(player) {
  const tags = player.getTags();
  return tags.includes("admin");
}
```

## 태그
#마인크래프트 #코딩 #스티브코딩 #베드락 #스크립트API #서버 #팀채팅 #멀티플레이 #애드온제작 #게임개발