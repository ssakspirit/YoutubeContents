---
title: "내가 자주 가는 위치를 저장하고 관리하기"
date: "2025-04-29"
thumbnail: "https://i.ytimg.com/vi/T4pG6pn2swU/hqdefault.jpg"
tags: ["고급", "베드락", "스크립트API", "소스코드", "설계자", "롱폼"]
url: "https://www.youtube.com/watch?v=T4pG6pn2swU"
duration: "3:11"
series: "스크립트 API 튜토리얼"
difficulty: "고급"
---

# 내가 자주 가는 위치를 저장하고 관리하기

<div align="center">
<img src="https://i.ytimg.com/vi/T4pG6pn2swU/hqdefault.jpg" alt="썸네일" width="600"/>
</div>

## 목차
- [소개](#소개)
- [주요 내용](#주요-내용)
- [실습 과정](#실습-과정)
- [자주 묻는 질문](#자주-묻는-질문)
- [추가 리소스](#추가-리소스)

## 소개
이 영상은 마인크래프트 베드락 에디션에서 스크립트 API를 활용하여 플레이어가 자주 가는 위치를 저장하고 관리할 수 있는 시스템을 구현하는 방법을 설명합니다. 게임 내에서 텔레포트 기능을 구현하고 UI를 통해 저장된 위치를 관리하는 고급 기능을 배울 수 있습니다. 동적 속성(Dynamic Property)을 활용하여 월드를 재접속해도 저장된 위치 정보가 유지되는 방법을 상세히 설명합니다.

## 주요 내용

### 1. 위치 저장 및 관리 시스템 설계
- 채팅 명령어를 통한 위치 저장 구현
- 커스텀 UI를 활용한 위치 선택 및 관리
- 동적 속성(Dynamic Property)을 활용한 데이터 저장

### 2. 나침반 아이템 활용
- 나침반 아이템을 활용한 UI 인터페이스 열기
- 저장된 위치로 텔레포트하는 기능 구현
- 아이템 사용 이벤트 활용

### 3. 고급 UI 시스템 구현
- Form UI를 활용한 사용자 인터페이스 설계
- 버튼과 드롭다운 메뉴를 활용한 관리 기능
- 위치 삭제 기능 구현

## 실습 과정

1. **위치 저장 시스템 시연 (00:00-00:35)**
   - 해안 마을 위치에서 "!저장 해안 마을" 명령어 입력
   - 성공적으로 위치가 저장되는 것 확인
   - 또 다른 위치(섬)에서 "!저장 섬" 명령어로 위치 저장

2. **저장된 위치로 이동하기 (00:36-01:00)**
   - 나침반 아이템 우클릭으로 UI 열기
   - 해안 마을 위치 선택하여 즉시 텔레포트
   - 섬 위치도 동일한 방식으로 이동 가능

3. **위치 삭제 기능 사용하기 (01:01-01:30)**
   - 삭제 버튼 선택하여 삭제 UI 열기
   - 드롭다운 메뉴에서 삭제할 위치(섬) 선택
   - 삭제 후 해당 위치가 목록에서 사라짐 확인

4. **월드 재접속 후에도 저장된 위치 유지 (01:31-01:50)**
   - 월드를 나갔다가 다시 들어와도 저장된 위치 정보 유지
   - 동적 속성(Dynamic Property)을 활용한 데이터 영속성 확인

5. **코드 설명 (01:51-끝)**
   - 채팅 명령어로 위치 저장하는 방법
   - 나침반 사용 이벤트 처리
   - UI 구성 및 동적 속성 활용 설명

## 자주 묻는 질문

**Q: 저장할 수 있는 위치의 개수에 제한이 있나요?**
A: 코드에서 별도의 제한을 두지 않았다면 기술적으로는 무제한이지만, 너무 많은 위치를 저장하면 UI가 복잡해질 수 있습니다. 실용적인 측면에서 20개 이내로 관리하는 것이 좋습니다.

**Q: 다른 플레이어도 내가 저장한 위치로 이동할 수 있나요?**
A: 기본 코드는 각 플레이어별로 저장 위치가 관리됩니다. 다른 플레이어가 접근할 수 있게 하려면 코드를 수정하여 글로벌 위치 시스템으로 변경해야 합니다.

**Q: 나침반 대신 다른 아이템을 사용할 수 있나요?**
A: 네, 코드에서 나침반 아이템 ID를 다른 아이템 ID로 변경하면 됩니다. 예를 들어 지도, 시계 등 다른 아이템으로 변경 가능합니다.

**Q: 위치 저장 명령어를 변경할 수 있나요?**
A: 코드에서 "!저장" 부분을 다른 접두사로 변경하여 커스터마이징할 수 있습니다. 예를 들어 "!위치", "!마크" 등으로 변경 가능합니다.

**Q: 동적 속성(Dynamic Property)은 무엇이며 왜 중요한가요?**
A: 동적 속성은 월드가 종료되어도 유지되는 데이터 저장 방식입니다. 일반 변수와 달리 월드를 다시 로드해도 데이터가 사라지지 않기 때문에 위치 저장 같은 영속적인 기능을 구현할 때 필수적입니다.

## 추가 리소스
- [스크립트 API 시작하기 영상](https://youtu.be/zBVdaQ0AXOY)
- [베드락 스크립트 API 공식 문서](https://learn.microsoft.com/ko-kr/minecraft/creator/scriptapi/minecraft/server/minecraft-server)
- [마인크래프트 UI 시스템 가이드](https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server-ui/minecraft-server-ui)
- [베드락 동적 속성 튜토리얼](https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/dynamicproperties)
- [스티브코딩 페이스북 페이지](https://www.facebook.com/stvcoding/)

## 이런 분들에게 추천합니다
- 스크립트 API를 활용한 고급 기능을 구현하고 싶은 개발자
- 마인크래프트 서버나 렐름에 텔레포트 시스템을 추가하고 싶은 관리자
- 게임 내 UI 시스템을 활용하는 방법을 배우고 싶은 사용자
- 동적 속성(Dynamic Property)을 활용한 데이터 저장 방법을 배우고 싶은 분
- 마인크래프트 베드락 에디션에서 고급 플러그인을 개발하려는 분

## 관련 튜토리얼
- [스크립트 API의 첫걸음, 채팅명령어 만들기]
- [스크립트 API로 본격적으로 애드온 제작하기]
- [마인크래프트에서 UI 만들기]
- [마을로 돌아가는 귀환서 만들기]
- [정해둔 위치로 이동하는 순간이동 아이템 제작]

## 실습 코드
```javascript
import { world, system, ItemStack, DynamicPropertiesDefinition, EntityTypes } from '@minecraft/server';
import { ActionFormData, ModalFormData } from '@minecraft/server-ui';

// 월드 로드 시 동적 속성 정의
world.afterEvents.worldInitialize.subscribe((event) => {
    const definition = new DynamicPropertiesDefinition();
    definition.defineObject("savedLocations", {});
    event.propertyRegistry.registerEntityTypeDynamicProperties(definition, EntityTypes.get("minecraft:player"));
});

// 채팅 이벤트 - 위치 저장 명령어 처리
world.beforeEvents.chatSend.subscribe((event) => {
    const player = event.sender;
    const message = event.message;
    
    // !저장 명령어 처리
    if (message.startsWith("!저장 ")) {
        event.cancel = true; // 채팅 메시지 발송 취소
        
        // 위치 이름 추출
        const locationName = message.substring(4).trim();
        if (locationName) {
            // 현재 위치 저장
            savePlayerLocation(player, locationName);
            player.sendMessage(`§a위치가 성공적으로 저장되었습니다: ${locationName}`);
        } else {
            player.sendMessage("§c위치 이름을 입력해주세요. 사용법: !저장 [이름]");
        }
    }
});

// 위치 저장 함수
function savePlayerLocation(player, name) {
    // 플레이어의 동적 속성에서 저장된 위치 가져오기
    let savedLocations = player.getDynamicProperty("savedLocations") || {};
    if (typeof savedLocations === "string") {
        savedLocations = JSON.parse(savedLocations);
    }
    
    // 현재 위치 저장
    const { x, y, z } = player.location;
    savedLocations[name] = { x, y, z };
    
    // 동적 속성에 다시 저장
    player.setDynamicProperty("savedLocations", JSON.stringify(savedLocations));
}

// 나침반 사용 이벤트
world.afterEvents.itemUse.subscribe((event) => {
    const player = event.source;
    const item = event.itemStack;
    
    // 나침반 아이템인지 확인
    if (item && item.typeId === "minecraft:compass") {
        // 위치 선택 UI 표시
        showLocationUI(player);
    }
});

// 위치 선택 UI 표시 함수
function showLocationUI(player) {
    // 플레이어의 저장된 위치 가져오기
    let savedLocations = player.getDynamicProperty("savedLocations") || "{}";
    if (typeof savedLocations === "string") {
        savedLocations = JSON.parse(savedLocations);
    }
    
    // 저장된 위치가 없는 경우
    const locationNames = Object.keys(savedLocations);
    if (locationNames.length === 0) {
        player.sendMessage("§c저장된 위치가 없습니다. !저장 [이름] 명령어로 위치를 저장하세요.");
        return;
    }
    
    // 위치 선택 UI 생성
    const form = new ActionFormData()
        .title("저장된 위치")
        .body("이동하고 싶은 위치를 선택하세요.");
    
    // 각 위치를 버튼으로 추가
    locationNames.forEach(name => {
        form.button(name);
    });
    
    // 삭제 옵션 추가
    form.button("§c저장된 위치 삭제");
    
    // UI 표시 및 응답 처리
    form.show(player).then(response => {
        if (response.canceled) return;
        
        // 삭제 옵션 선택
        if (response.selection === locationNames.length) {
            showDeleteLocationUI(player);
            return;
        }
        
        // 선택한 위치로 텔레포트
        const selectedName = locationNames[response.selection];
        const location = savedLocations[selectedName];
        
        player.teleport(
            { x: location.x, y: location.y, z: location.z },
            player.dimension,
            0, 0 // yaw, pitch 유지
        );
        
        player.sendMessage(`§a${selectedName} 위치로 이동했습니다.`);
    });
}

// 위치 삭제 UI 표시 함수
function showDeleteLocationUI(player) {
    // 플레이어의 저장된 위치 가져오기
    let savedLocations = player.getDynamicProperty("savedLocations") || "{}";
    if (typeof savedLocations === "string") {
        savedLocations = JSON.parse(savedLocations);
    }
    
    const locationNames = Object.keys(savedLocations);
    
    // 삭제 UI 생성
    const form = new ModalFormData()
        .title("저장된 위치 삭제")
        .dropdown("삭제할 위치 선택", locationNames);
    
    // UI 표시 및 응답 처리
    form.show(player).then(response => {
        if (response.canceled) return;
        
        const selectedName = locationNames[response.formValues[0]];
        
        // 선택한 위치 삭제
        delete savedLocations[selectedName];
        player.setDynamicProperty("savedLocations", JSON.stringify(savedLocations));
        
        player.sendMessage(`§c${selectedName} 위치가 삭제되었습니다.`);
    });
}
```

## 태그
`#마인크래프트` `#스크립트API` `#텔레포트` `#위치저장` `#베드락` `#스티브코딩` `#UI시스템` `#동적속성`