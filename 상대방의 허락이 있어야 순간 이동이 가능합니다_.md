---
title: "상대방의 허락이 있어야 순간 이동이 가능합니다."
date: "2025-04-25"
thumbnail: "https://i.ytimg.com/vi/XGtmmp0kiKU/hqdefault.jpg"
tags: ["중급", "베드락", "스크립트API", "소스코드", "설계자", "롱폼"]
url: "https://youtu.be/XGtmmp0kiKU?si=viUFW_ooBAsn438c"
duration: "1:10"
series: "스크립트 API 튜토리얼"
episode: 3
difficulty: "중급"
---

# 상대방의 허락이 있어야 순간 이동이 가능합니다.

<div align="center">
<img src="https://i.ytimg.com/vi/XGtmmp0kiKU/hqdefault.jpg" alt="썸네일" width="600"/>
</div>

## 목차
- [소개](#소개)
- [주요 내용](#주요-내용)
- [시스템 작동 방식](#시스템-작동-방식)
- [코드 설정 값](#코드-설정-값)
- [자주 묻는 질문](#자주-묻는-질문)
- [추가 리소스](#추가-리소스)

## 소개
이 영상은 마인크래프트 베드락 에디션에서 스크립트 API를 활용하여 상대방의 허락이 필요한 순간 이동 시스템을 구현하는 방법을 설명합니다. 이 시스템을 통해 플레이어는 다른 플레이어에게 이동 요청을 보내고, 상대방이 수락해야만 순간 이동할 수 있는 안전한 이동 메커니즘을 구현할 수 있습니다.

## 주요 내용

### 1. 허락 기반 순간 이동 시스템
- 채팅 명령어를 통한 간편한 순간 이동 요청
- 상대방의 명시적 동의가 필요한 안전한 시스템
- 사용자 친화적인 인터페이스로 쉽게 요청 및 응답 가능
- 다양한 상황에 대한 피드백 메시지 제공

### 2. 요청 및 응답 프로세스
- 채팅창에 `/warp` 명령어 입력으로 시작
- 접속한 플레이어 목록에서 대상 선택 가능
- 대상자에게 수락/거절 메시지 전송
- 수락 시 지연 시간 후 순간 이동 실행
- 거절 또는 무응답 시 요청 자동 취소

### 3. 시스템 제한 및 안전 장치
- 순간 이동 후 일정 시간 동안의 쿨타임 적용
- 요청 만료 시간 설정으로 무한 대기 방지
- 한 명의 플레이어만 한 번에 한 요청 처리 가능
- 접속한 플레이어가 없을 경우 적절한 피드백 제공

## 시스템 작동 방식

### 기본 사용법
1. 채팅창에 `/warp` 명령어 입력
2. 현재 접속한 플레이어 목록 표시
3. 순간 이동하고 싶은 플레이어 선택
4. 대상 플레이어에게 수락/거절 메시지 전송
5. 수락 시 3초 후 요청자가 대상 플레이어 위치로 이동
6. 이동 후 3분 동안 쿨타임 적용

### 요청 수락 및 거절 과정
- 대상 플레이어는 채팅창에 수락/거절 버튼 확인
- 수락 클릭 시 요청자에게 이동 준비 메시지 전송
- 거절 클릭 시 요청자에게 거절 메시지 전송
- 1분 이내 응답이 없을 경우 요청 자동 취소
- 대기 중 다른 플레이어의 요청은 처리 불가 메시지 출력

### 오류 처리 및 예외 상황
- 아무도 접속하지 않은 경우 "워프할 수 있는 플레이어가 없습니다" 메시지 표시
- 대기 중인 요청이 있을 때 새 요청 시도 시 대기 메시지 표시
- 쿨타임 중 요청 시도 시 남은 시간 안내 메시지 표시

## 코드 설정 값

```javascript
// 시스템 설정값
const cooldownTime = 180; // 쿨타임(초): 3분
const requestExpiryTime = 60; // 요청 만료 시간(초): 1분
const teleportDelay = 3; // 텔레포트 지연 시간(초): 3초
```

이 설정값을 통해 다음 항목을 조절할 수 있습니다:

1. **쿨타임 (cooldownTime)**: 순간 이동 후 다시 요청할 수 있을 때까지의 대기 시간
2. **요청 만료 시간 (requestExpiryTime)**: 응답이 없을 경우 자동으로 취소되는 시간
3. **텔레포트 지연 시간 (teleportDelay)**: 수락 후 실제 이동까지 기다리는 시간

이 값들은 필요에 따라 사용자가 직접 조절하여 게임플레이 환경에 맞게 설정할 수 있습니다.

## 자주 묻는 질문

**Q: 여러 플레이어에게 동시에 요청을 보낼 수 있나요?**  
A: 아니요, 한 번에 하나의 요청만 보낼 수 있습니다. 이는 시스템을 단순하게 유지하고 혼란을 방지하기 위한 설계입니다.

**Q: 쿨타임은 어떻게 변경할 수 있나요?**  
A: 코드 상단의 `cooldownTime` 값을 수정하여 쿨타임을 조절할 수 있습니다. 기본값은 180초(3분)로 설정되어 있습니다.

**Q: 플레이어가 응답하지 않으면 어떻게 되나요?**  
A: 요청 만료 시간(기본 1분) 동안 응답이 없으면 요청이 자동으로 취소됩니다. 이는 `requestExpiryTime` 값으로 조절 가능합니다.

**Q: 이 시스템을 서버에 적용하려면 어떻게 해야 하나요?**  
A: 스크립트 API를 지원하는 베드락 서버에 애드온 형태로 적용해야 합니다. 영상 설명에 있는 링크에서 전체 코드를 얻고 관련 튜토리얼을 참고하여 설치할 수 있습니다.

## 추가 리소스
- [전체 코드 GitHub 저장소](https://github.com/ssakspirit/scriptAPI/blob/main/warpSystem.js)
- [스크립트 API 시작하기](https://youtu.be/zBVdaQ0AXOY)
- [복붙한 코드를 애드온으로 바꾸기](https://youtu.be/lZuJxdKgUMg?si=GCOiludeu4HzUGbl)
- [브릿지 가이드](https://youtu.be/L2s8-w8HXIk?si=aWJONVaLN0kngFtg)
- [마인크래프트 베드락 공식 문서](https://learn.microsoft.com/ko-kr/minecraft/creator/scriptapi/minecraft/server/minecraft-server)
- [스티브코딩 페이스북 페이지](https://www.facebook.com/stvcoding/)

## 이런 분들에게 추천합니다
- 마인크래프트 서버를 안전하게 운영하고 싶은 관리자
- 플레이어 간 이동 시스템을 구현하고 싶은 서버 개발자
- 스크립트 API를 활용한 실용적인 기능을 배우고 싶은 코더
- 마인크래프트에 RPG 요소를 추가하고 싶은 콘텐츠 크리에이터
- 채팅 인터페이스를 활용한 상호작용 시스템에 관심 있는 개발자

## 관련 튜토리얼
- [스크립트 API의 첫걸음, 채팅명령어 만들기](https://www.youtube.com/watch?v=zBVdaQ0AXOY)
- [스크립트 API로 본격적으로 애드온 제작하기](https://www.youtube.com/watch?v=)
- [UI 활용한 대화형 NPC 만들기](https://www.youtube.com/watch?v=)
- [서버에 입장, 재입장하는 플레이어에게 맞춤 메시지 보내기](https://www.youtube.com/watch?v=)

## 실습 코드
```javascript
// warpSystem.js

// 시스템 설정값
const cooldownTime = 180; // 쿨타임(초): 3분
const requestExpiryTime = 60; // 요청 만료 시간(초): 1분
const teleportDelay = 3; // 텔레포트 지연 시간(초): 3초

// 플레이어 요청 상태 관리
const playerRequests = new Map();
const playerCooldowns = new Map();

// 워프 명령어 등록
system.afterEvents.chatSend.subscribe((event) => {
    const player = event.sender;
    const message = event.message;
    
    if (message.toLowerCase() === "warp") {
        event.cancel = true;
        handleWarpCommand(player);
    }
});

// 워프 명령어 처리 함수
function handleWarpCommand(player) {
    // 쿨타임 확인
    if (isPlayerOnCooldown(player)) {
        const remainingTime = getRemainingCooldown(player);
        player.sendMessage(`§c워프 쿨타임: ${remainingTime}초 남았습니다.`);
        return;
    }
    
    // 진행 중인 요청 확인
    if (hasActiveRequest(player)) {
        player.sendMessage("§c이미 워프 요청이 진행 중입니다.");
        return;
    }
    
    // 온라인 플레이어 목록 표시
    const onlinePlayers = world.getAllPlayers().filter(p => p.id !== player.id);
    
    if (onlinePlayers.length === 0) {
        player.sendMessage("§c워프할 수 있는 플레이어가 없습니다.");
        return;
    }
    
    // 플레이어 목록 UI 표시
    const formData = new ActionFormData()
        .setTitle("워프 요청")
        .setBody("워프할 플레이어를 선택하세요:");
    
    onlinePlayers.forEach(p => {
        formData.addButton(p.name);
    });
    
    formData.show(player).then(response => {
        if (response.canceled) return;
        
        const targetPlayer = onlinePlayers[response.selection];
        sendWarpRequest(player, targetPlayer);
    });
}

// 워프 요청 전송 함수
function sendWarpRequest(sender, target) {
    // 요청 저장
    playerRequests.set(sender.id, {
        target: target.id,
        timestamp: Date.now(),
        pending: true
    });
    
    // 요청 메시지 전송
    sender.sendMessage(`§a${target.name}에게 워프 요청을 보냈습니다.`);
    
    // 대상에게 수락/거절 UI 표시
    const formData = new ActionFormData()
        .setTitle("워프 요청")
        .setBody(`${sender.name}님이 당신에게 워프하려고 합니다. 수락하시겠습니까?`)
        .addButton("수락")
        .addButton("거절");
    
    formData.show(target).then(response => {
        handleWarpResponse(sender, target, response);
    });
    
    // 요청 만료 타이머 설정
    system.runTimeout(() => {
        const request = playerRequests.get(sender.id);
        if (request && request.pending) {
            playerRequests.delete(sender.id);
            sender.sendMessage("§c워프 요청이 만료되었습니다.");
        }
    }, requestExpiryTime * 20); // 틱 단위로 변환 (20틱 = 1초)
}

// 워프 응답 처리 함수
function handleWarpResponse(sender, target, response) {
    const request = playerRequests.get(sender.id);
    
    // 요청이 없거나 이미 처리된 경우
    if (!request || !request.pending) return;
    
    // 요청 처리 완료 표시
    request.pending = false;
    
    // 취소된 경우
    if (response.canceled) {
        playerRequests.delete(sender.id);
        sender.sendMessage(`§c${target.name}님이 응답하지 않았습니다.`);
        return;
    }
    
    // 수락한 경우
    if (response.selection === 0) {
        sender.sendMessage(`§a${target.name}님이 워프 요청을 수락했습니다. ${teleportDelay}초 후 이동합니다.`);
        target.sendMessage(`§a${sender.name}님의 워프 요청을 수락했습니다.`);
        
        // 지연 시간 후 텔레포트 실행
        system.runTimeout(() => {
            teleportPlayer(sender, target);
        }, teleportDelay * 20);
    } 
    // 거절한 경우
    else {
        playerRequests.delete(sender.id);
        sender.sendMessage(`§c${target.name}님이 워프 요청을 거절했습니다.`);
        target.sendMessage(`§c${sender.name}님의 워프 요청을 거절했습니다.`);
    }
}

// 실제 텔레포트 실행 함수
function teleportPlayer(player, target) {
    playerRequests.delete(player.id);
    
    // 텔레포트 실행
    player.teleport(target.location, {
        dimension: target.dimension,
        rotation: player.rotation
    });
    
    // 쿨타임 설정
    setPlayerCooldown(player);
    
    // 완료 메시지
    player.sendMessage(`§a${target.name}님에게 워프했습니다.`);
    target.sendMessage(`§a${player.name}님이 당신에게 워프했습니다.`);
}

// 쿨타임 관련 함수들
function setPlayerCooldown(player) {
    playerCooldowns.set(player.id, Date.now() + cooldownTime * 1000);
}

function isPlayerOnCooldown(player) {
    const cooldownEnd = playerCooldowns.get(player.id);
    return cooldownEnd && cooldownEnd > Date.now();
}

function getRemainingCooldown(player) {
    const cooldownEnd = playerCooldowns.get(player.id);
    return Math.ceil((cooldownEnd - Date.now()) / 1000);
}

function hasActiveRequest(player) {
    const request = playerRequests.get(player.id);
    return request && request.pending;
}
```

## 태그
#마인크래프트 #베드락 #스크립트API #순간이동 #애드온제작 #서버관리 #코딩 #스티브코딩 #멀티플레이